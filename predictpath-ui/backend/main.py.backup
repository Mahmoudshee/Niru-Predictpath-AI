import asyncio
import subprocess
import os
import signal
import json
import uuid
from datetime import datetime
from typing import List
from fastapi import FastAPI, WebSocket, HTTPException, UploadFile, File
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
import glob
import shutil

app = FastAPI()

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Root Directory of Tools
TOOLS_ROOT = os.path.abspath(os.path.join(os.path.dirname(__file__), "..", ".."))
UPLOADS_DIR = os.path.join(TOOLS_ROOT, "Tool1", "data", "uploads")
SCAN_HISTORY_FILE = os.path.join(TOOLS_ROOT, "predictpath-ui", "backend", "scan_history.json")
os.makedirs(UPLOADS_DIR, exist_ok=True)

class ToolRunRequest(BaseModel):
    tool_name: str
    command: str
    cwd: str

class ResetRequest(BaseModel):
    type: str  # "soft" or "hard"

class ScanRequest(BaseModel):
    scan_type: str

@app.get("/")
def health_check():
    return {"status": "ok", "tools_root": TOOLS_ROOT}

@app.post("/api/upload")
async def upload_file(file: UploadFile = File(...)):
    try:
        file_path = os.path.join(UPLOADS_DIR, file.filename)
        with open(file_path, "wb") as buffer:
            shutil.copyfileobj(file.file, buffer)
        return {"filename": file.filename, "path": f"data/uploads/{file.filename}"}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/api/reset")
async def reset_system(request: ResetRequest):
    deleted_files = []
    
    artifacts = [
        {"path": os.path.join(TOOLS_ROOT, "Tool1", "data", "output"), "type": "dir"},
        {"path": os.path.join(TOOLS_ROOT, "Tool1", "data", "dlq"), "type": "dir"},
        {"path": os.path.join(TOOLS_ROOT, "Tool1", "ingestion_summary.json"), "type": "file"},
        {"path": os.path.join(TOOLS_ROOT, "Tool1", "status.json"), "type": "file"},
        {"path": os.path.join(TOOLS_ROOT, "Tool1", "ingestion_summary.json"), "type": "file"},
        # Tool 2
        {"path": os.path.join(TOOLS_ROOT, "Tool2", "path_report.json"), "type": "file"},
        # Tool 6 Report (Visuals)
        {"path": os.path.join(TOOLS_ROOT, "Tool6", "status.json"), "type": "file"},
        {"path": os.path.join(TOOLS_ROOT, "Tool3", "trajectory_forecast.json"), "type": "file"},
        {"path": os.path.join(TOOLS_ROOT, "Tool4", "response_plan.json"), "type": "file"},
        {"path": os.path.join(TOOLS_ROOT, "Tool5", "execution_report.json"), "type": "file"},
        {"path": os.path.join(TOOLS_ROOT, "Tool5", "execution_audit.log"), "type": "file"},
        # Vulnerability scan logs
        {"path": os.path.join(TOOLS_ROOT, "logs", "nmap"), "type": "dir"},
        {"path": os.path.join(TOOLS_ROOT, "logs", "openvas"), "type": "dir"},
        {"path": os.path.join(TOOLS_ROOT, "logs", "nikto"), "type": "dir"},
        {"path": os.path.join(TOOLS_ROOT, "logs", "nuclei"), "type": "dir"},
    ]
    
    if request.type == "hard":
        # Delete main DB and any WAL/SHM files (sqlite artifacts)
        db_base = os.path.join(TOOLS_ROOT, "Tool6", "data", "governance.db")
        for db_file in glob.glob(db_base + "*"):
             artifacts.append({"path": db_file, "type": "file"})
        
        artifacts.append({"path": os.path.join(TOOLS_ROOT, "Tool6", "test_tamper.db"), "type": "file"})

    try:
        for artifact in artifacts:
            path = artifact["path"]
            if os.path.exists(path):
                if artifact["type"] == "file":
                    os.remove(path)
                    deleted_files.append(os.path.basename(path))
                elif artifact["type"] == "dir":
                    for item in os.listdir(path):
                        item_path = os.path.join(path, item)
                        if os.path.isfile(item_path):
                            os.remove(item_path)
                        elif os.path.isdir(item_path):
                            shutil.rmtree(item_path)
                    deleted_files.append(f"{os.path.basename(path)}/*")
                    
        return {"status": "success", "deleted": deleted_files, "mode": request.type}
            
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Reset failed: {str(e)}")

@app.websocket("/ws/run")
async def websocket_run(websocket: WebSocket):
    await websocket.accept()
    try:
        data = await websocket.receive_json()
        tool_dir = data.get("tool_dir")
        command_str = data.get("command")
        
        cwd = os.path.join(TOOLS_ROOT, tool_dir)
        
        await websocket.send_text(f"> cd {tool_dir}\n")
        await websocket.send_text(f"> {command_str}\n")
        
        # FORCE UTF-8 ENCODING for Subprocess
        env = os.environ.copy()
        env["PYTHONIOENCODING"] = "utf-8"
        # Also try to disable Rich legacy windows renderer if possible, or force color system
        # env["TERM"] = "xterm-256color" 
        
        process = await asyncio.create_subprocess_shell(
            command_str,
            cwd=cwd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            env=env
        )
        
        async def stream_output(stream):
            while True:
                line = await stream.readline()
                if not line:
                    break
                decoded = line.decode('utf-8', errors='replace')
                await websocket.send_text(decoded)

        await asyncio.gather(
            stream_output(process.stdout),
            stream_output(process.stderr)
        )
        await process.wait()
        await websocket.send_text(f"\n[Process exited with code {process.returncode}]")
        await websocket.close()
        
    except Exception as e:
        await websocket.send_text(f"\nError: {str(e)}")
        await websocket.close()

@app.get("/api/file")
def read_file(path: str):
    abs_path = os.path.abspath(os.path.join(TOOLS_ROOT, path))
    if not abs_path.startswith(TOOLS_ROOT):
        raise HTTPException(status_code=403, detail="Access denied")
    if not os.path.exists(abs_path):
        raise HTTPException(status_code=404, detail="File not found")
    with open(abs_path, "r", encoding="utf-8") as f:
        return {"content": f.read()}

@app.delete("/api/file")
def delete_file(path: str):
    """Delete a specific log file"""
    abs_path = os.path.abspath(os.path.join(TOOLS_ROOT, path))
    
    # Security: only allow deleting files in logs directory
    logs_dir = os.path.join(TOOLS_ROOT, "logs")
    
    if not abs_path.startswith(logs_dir):
        raise HTTPException(status_code=403, detail="Can only delete files in logs directory")
    
    if not os.path.exists(abs_path):
        raise HTTPException(status_code=404, detail="File not found")
    
    try:
        os.remove(abs_path)
        
        # Also remove from scan history
        history = load_scan_history()
        history["scans"] = [s for s in history["scans"] if s["log_path"] != path]
        save_scan_history(history)
        
        return {"status": "success", "message": f"Deleted {os.path.basename(abs_path)}"}
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to delete file: {str(e)}")

# Helper functions for scan history
def load_scan_history():
    if os.path.exists(SCAN_HISTORY_FILE):
        with open(SCAN_HISTORY_FILE, "r") as f:
            return json.load(f)
    return {"scans": []}

def save_scan_history(history):
    with open(SCAN_HISTORY_FILE, "w") as f:
        json.dump(history, f, indent=2)

def add_scan_to_history(scan_type, status, log_path, file_name):
    history = load_scan_history()
    scan_entry = {
        "id": str(uuid.uuid4()),
        "scan_type": scan_type,
        "timestamp": datetime.now().isoformat(),
        "status": status,
        "log_path": log_path,
        "file_name": file_name
    }
    history["scans"].insert(0, scan_entry)  # Most recent first
    save_scan_history(history)
    return scan_entry

@app.get("/api/scans/history")
def get_scan_history():
    return load_scan_history()

@app.websocket("/ws/scan")
async def websocket_scan(websocket: WebSocket):
    await websocket.accept()
    try:
        data = await websocket.receive_json()
        scan_type = data.get("scan_type")
        
        await websocket.send_text(f"> Initializing {scan_type.upper()} Security Scanner...")
        await asyncio.sleep(0.5)
        
        # For network scans, run actual Nmap and OpenVAS scripts
        if scan_type == "network":
            await run_network_scan(websocket)
        else:
            # For web and endpoint, keep simulation for now
            await run_simulated_scan(websocket, scan_type)
        
    except Exception as e:
        await websocket.send_text(f"\n✗ Error: {str(e)}")
        await websocket.close()


async def run_network_scan(websocket: WebSocket):
    """Execute Nmap first, then prompt user for OpenVAS deep scan"""
    try:
        scripts_dir = os.path.join(TOOLS_ROOT, "scripts")
        logs_dir = os.path.join(TOOLS_ROOT, "logs")
        
        # Verify scripts exist
        nmap_script = os.path.join(scripts_dir, "run-nmap.ps1")
        openvas_script = os.path.join(scripts_dir, "run-openvas.ps1")
        
        if not os.path.exists(nmap_script):
            await websocket.send_text(f"✗ Error: Nmap script not found at {nmap_script}")
            await websocket.close()
            return
        
        await websocket.send_text("======================================")
        await websocket.send_text(" PredictPath AI — Network Scan Started")
        await websocket.send_text("======================================")
        await websocket.send_text("")
        
        # ============================================
        # STAGE 1: Nmap Network Discovery
        # ============================================
        await websocket.send_text("STAGE 1: Nmap Network Discovery")
        await websocket.send_text("═══════════════════════════════════════")
        await websocket.send_text("")
        
        # Default target - can be made configurable later
        target = "127.0.0.1"  # Scan localhost for testing
        
        await websocket.send_text(f"[+] Target: {target}")
        await websocket.send_text("[+] Starting Nmap scan...")
        await websocket.send_text("")
        
        nmap_command = f'powershell.exe -ExecutionPolicy Bypass -File "{nmap_script}" -Target "{target}"'
        
        # Execute Nmap script
        process = await asyncio.create_subprocess_shell(
            nmap_command,
            cwd=TOOLS_ROOT,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            env=os.environ.copy()
        )
        
        # Stream Nmap output
        async def stream_nmap_output(stream):
            while True:
                line = await stream.readline()
                if not line:
                    break
                decoded = line.decode('utf-8', errors='replace').strip()
                if decoded:
                    await websocket.send_text(decoded)
        
        await asyncio.gather(
            stream_nmap_output(process.stdout),
            stream_nmap_output(process.stderr)
        )
        await process.wait()
        
        nmap_success = process.returncode == 0
        
        if not nmap_success:
            await websocket.send_text("")
            await websocket.send_text(f"✗ Nmap scan failed with exit code {process.returncode}")
            await websocket.send_text("✗ Workflow terminated.")
            await websocket.close()
            return
        
        await websocket.send_text("")
        await websocket.send_text("✓ Nmap scan completed successfully")
        
        # Find and save Nmap log files
        nmap_log_file = None
        nmap_logs_dir = os.path.join(logs_dir, "nmap")
        if os.path.exists(nmap_logs_dir):
            nmap_files = sorted(glob.glob(os.path.join(nmap_logs_dir, "nmap-*.xml")), 
                               key=os.path.getmtime, reverse=True)
            if nmap_files:
                latest_nmap = nmap_files[0]
                nmap_log_file = os.path.basename(latest_nmap)
                rel_path = os.path.relpath(latest_nmap, TOOLS_ROOT)
                await websocket.send_text(f"✓ Nmap report saved: {nmap_log_file}")
                
                # Add to scan history
                add_scan_to_history("network-nmap", "completed", rel_path, nmap_log_file)
        
        await websocket.send_text("")
        await websocket.send_text("Scan completed successfully.")
        await websocket.send_text("Nmap report saved.")
        await websocket.send_text("")
        
        # ============================================
        # USER PROMPT: Ask about OpenVAS deep scan
        # ============================================
        await websocket.send_text("═══════════════════════════════════════")
        await websocket.send_text("USER DECISION REQUIRED")
        await websocket.send_text("═══════════════════════════════════════")
        await websocket.send_text("")
        await websocket.send_text("Nmap scan completed. Do you want to run a deeper")
        await websocket.send_text("vulnerability scan using OpenVAS?")
        await websocket.send_text("")
        await websocket.send_text("⚠ Note: OpenVAS deep scan can take 15-60 minutes")
        await websocket.send_text("")
        
        # Send special prompt message that UI will recognize
        print(f"[DEBUG] Sending user prompt to WebSocket...")  # Debug log
        await websocket.send_json({
            "type": "user_prompt",
            "message": "Run deeper vulnerability scan with OpenVAS?",
            "options": ["Yes", "No"]
        })
        print(f"[DEBUG] User prompt sent successfully")  # Debug log
        
        # Wait for user response
        try:
            response_data = await asyncio.wait_for(
                websocket.receive_json(),
                timeout=300.0  # 5 minute timeout for user decision
            )
            user_choice = response_data.get("choice", "").lower()
        except asyncio.TimeoutError:
            await websocket.send_text("")
            await websocket.send_text("⚠ No response received. Defaulting to 'No'.")
            user_choice = "no"
        
        await websocket.send_text("")
        await websocket.send_text(f"User selected: {user_choice.upper()}")
        await websocket.send_text("")
        
        # ============================================
        # BRANCH: User selected NO
        # ============================================
        if user_choice != "yes":
            await websocket.send_text("✓ Workflow completed.")
            await websocket.send_text("✓ Download Nmap report from 'Generated Scan Logs'")
            await websocket.send_text("")
            await websocket.send_text("======================================")
            await websocket.send_text(" Network Security Analysis COMPLETED")
            await websocket.send_text("======================================")
            await websocket.close()
            return
        
        # ============================================
        # STAGE 2: OpenVAS Deep Vulnerability Scan
        # ============================================
        await websocket.send_text("STAGE 2: OpenVAS Deep Vulnerability Scan")
        await websocket.send_text("═══════════════════════════════════════")
        await websocket.send_text("")
        
        # Check if OpenVAS script exists
        if not os.path.exists(openvas_script):
            await websocket.send_text("✗ OpenVAS script not found")
            await websocket.send_text("✓ Workflow completed with Nmap only")
            await websocket.close()
            return
        
        # Check Docker availability
        await websocket.send_text("[+] Checking OpenVAS readiness...")
        docker_check = await asyncio.create_subprocess_shell(
            "docker ps --filter name=openvas --format {{.Names}}",
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE
        )
        docker_out, _ = await docker_check.communicate()
        docker_running = "openvas" in docker_out.decode('utf-8', errors='replace')
        
        if not docker_running:
            await websocket.send_text("")
            await websocket.send_text("⚠ OpenVAS container not running")
            await websocket.send_text("")
            await websocket.send_text("Initializing deep vulnerability scanner (first-time setup).")
            await websocket.send_text("This may take some time.")
            await websocket.send_text("")
            await websocket.send_text("ℹ To start OpenVAS manually:")
            await websocket.send_text("  docker run -d -p 443:443 --name openvas mikesplain/openvas")
            await websocket.send_text("")
            await websocket.send_text("✗ OpenVAS initialization required - skipping for now")
            await websocket.send_text("✓ Workflow completed with Nmap only")
            await websocket.close()
            return
        
        await websocket.send_text("✓ OpenVAS container is ready")
        await websocket.send_text("")
        await websocket.send_text("[+] Starting deep vulnerability scan...")
        await websocket.send_text("[+] This will take 15-60 minutes depending on target size")
        await websocket.send_text("")
        
        # Execute OpenVAS script
        openvas_command = f'powershell.exe -ExecutionPolicy Bypass -File "{openvas_script}" -Target "{target}"'
        
        openvas_process = await asyncio.create_subprocess_shell(
            openvas_command,
            cwd=TOOLS_ROOT,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            env=os.environ.copy()
        )
        
        # Stream OpenVAS output
        async def stream_openvas_output(stream):
            while True:
                line = await stream.readline()
                if not line:
                    break
                decoded = line.decode('utf-8', errors='replace').strip()
                if decoded:
                    await websocket.send_text(decoded)
        
        await asyncio.gather(
            stream_openvas_output(openvas_process.stdout),
            stream_openvas_output(openvas_process.stderr)
        )
        await openvas_process.wait()
        
        openvas_success = openvas_process.returncode == 0
        
        await websocket.send_text("")
        if openvas_success:
            await websocket.send_text("✓ Deep vulnerability scan completed successfully")
            
            # Find OpenVAS log files
            openvas_logs_dir = os.path.join(logs_dir, "openvas")
            if os.path.exists(openvas_logs_dir):
                openvas_files = sorted(glob.glob(os.path.join(openvas_logs_dir, "openvas-*.xml")), 
                                      key=os.path.getmtime, reverse=True)
                if openvas_files:
                    latest_openvas = openvas_files[0]
                    openvas_log_file = os.path.basename(latest_openvas)
                    rel_path = os.path.relpath(latest_openvas, TOOLS_ROOT)
                    await websocket.send_text(f"✓ OpenVAS report saved: {openvas_log_file}")
                    
                    # Add to scan history
                    add_scan_to_history("network-openvas", "completed", rel_path, openvas_log_file)
        else:
            await websocket.send_text(f"✗ OpenVAS scan failed with exit code {openvas_process.returncode}")
        
        await websocket.send_text("")
        await websocket.send_text("======================================")
        await websocket.send_text(" Network Security Analysis COMPLETED")
        await websocket.send_text("======================================")
        await websocket.send_text("")
        await websocket.send_text("✓ All reports saved to /logs folder")
        await websocket.send_text("✓ Download reports from 'Generated Scan Logs'")
        
        await websocket.close()
        
    except Exception as e:
        await websocket.send_text(f"\n✗ Network scan error: {str(e)}")
        import traceback
        await websocket.send_text(f"✗ Details: {traceback.format_exc()}")
        await websocket.close()


async def run_simulated_scan(websocket: WebSocket, scan_type: str):
    """Keep simulated scans for web and endpoint (for now)"""
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    log_filename = f"{scan_type}_scan_{timestamp}.log"
    
    # Save to logs directory, not Tool1/data/uploads
    logs_dir = os.path.join(TOOLS_ROOT, "logs", scan_type)
    os.makedirs(logs_dir, exist_ok=True)
    log_path = os.path.join(logs_dir, log_filename)
    
    # Simulate scan execution with realistic output
    scan_steps = {
        "web": [
            "Starting web application security scan...",
            "Target: https://example.com",
            "Checking SSL/TLS configuration...",
            "SSL certificate valid (expires: 2026-12-31)",
            "Scanning for common vulnerabilities...",
            "Testing for SQL injection...",
            "Testing for XSS vulnerabilities...",
            "Testing for CSRF protection...",
            "Performing traffic stress test...",
            "Response time: 120ms (Good)",
            "Scan complete. No critical vulnerabilities found."
        ],
        "endpoint": [
            "Starting Wazuh endpoint hygiene scan...",
            "Checking system integrity...",
            "Antivirus status: Active",
            "Firewall status: Enabled",
            "Last system update: 2026-01-20",
            "Running CVE mapping...",
            "Detected outdated package: openssl-1.1.1 (CVE-2023-5678)",
            "Initiating Velociraptor forensic artifact collection...",
            "Collecting process list...",
            "Collecting network connections...",
            "Collecting registry keys...",
            "Scan complete. 1 CVE detected, artifacts collected."
        ]
    }
    
    steps = scan_steps.get(scan_type, ["Unknown scan type"])
    log_lines = []
    
    for step in steps:
        await websocket.send_text(step)
        log_lines.append(f"{datetime.now().isoformat()} - {step}")
        await asyncio.sleep(0.3)
    
    # Write log file
    with open(log_path, "w") as f:
        f.write("\n".join(log_lines))
    
    # Add to history with correct path
    rel_path = os.path.relpath(log_path, TOOLS_ROOT)
    add_scan_to_history(scan_type, "completed", rel_path, log_filename)
    
    await websocket.send_text(f"\n✓ Log file generated: {log_filename}")
    await websocket.send_text(f"✓ Scan completed successfully")
    await websocket.close()


if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
